//определить множество вершин графа, расстояние от которых до заданной вершины не более n

/*Алгоритм Дейкстры находит кратчиайший путь от вершины s ко всем другим вершинам и к требуемой вершине t. Алгоритм работает 
поэтапно, находя на каждом этапе кратчайший путь от s к новой промежуточной вершине x. То есть, в каждом цикле мы добавляем
одну вершину к дереву вершин, для которых мы знаем кратчайший путь из s.*/

#include <iostream>
#include <fstream>

const double inf = 1E9;

using namespace std;

ifstream inp("input.txt");
ofstream outp("output.txt");

int n, g[100][100], length; //имеется граф g с n ребрами

void dksrt(int s, int k)//алгоритм Дейкстры
{
	int distance[100];//массив хранения путей 
	int u;
	int min = 10000;
	bool visited[100];//посещена вершина?

	for (int i = 0; i<n; i++)
	{
		distance[i] = inf; //путей из одной вершины во все остальные пока нет
		visited[i] = false; //ни одна вершина не посещена
	}

	distance[s]=0;//нет петель

	for (int count = 0; count<n; count++)
	{
		for (int i=0; i<n; i++)
			if (!visited[i] && distance[i]<=inf)//если смежная вершина не просмотрена и путь есь
			{
				min = distance[i]; 
				u = i; //запомминаем вершину, у которой путь минимален
			}

			visited[u] = true;//просмотрели ее

			for (int i=0; i<n; i++)
				if (!visited[i] && g[u][i] distance[u]!=inf && distance[u]+g[u][i]<distance[i])//если вершина не просмотрена, есть путь из u 
					//в i, и выполняется алгоритм кратчайших путей(алгоритм Дейкстры): если существует ребро, через которое
					//существует меньший путь, чем каким он является сейчас
					distance[i] = distance[u]+g[u][i];//записываем этот минимальный путь(смотрим с помощью матрицы g)
	}

	if (distance[k - 1] < length)//если путь до k существует, то выводим его
		outp << s+1 << " > "<< k << " = " << distance[k - 1] << endl;
	else//иначе выводим сообщение, что его нет
		outp << s+1 << " > "<< k << " = " << "No" << endl;
}

int main()
{
	int s; //заданная вершина

	inp >> s; //данная вершина
	inp >> n; //количество вершин
	inp >> length; //заданный путь

	//считываем сам граф
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; j++)
			inp >> g[i][j];//считыываем матрицу весов

	for (int i = 0; i<n; i++)
		dksrt(i, s);//запускаем алгоритим в цикле, так как нам нужно от всег вершин до данной, а алгоритм считает
	//массив только от одной вершины

	return 0;
}