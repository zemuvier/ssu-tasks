/*Оптимальным из i в j будет путь или не проходящий через k, или проходящий. Заключить о наличии второго случая, значит, 
установить, что такой путь идет из i до k, а затем из k до j, поэтому должно заменить, значение кратчайшего пути D[i][j] суммой 
D[i][k]+D[k][j].*/
#include <iostream>

using namespace std;

const int maxV=1000;
int i, j; //путь из i в j
int n;
int GR[maxV][maxV];

void FU(int D[][maxV], int V)//алгоритм Флойда-Уоршелла, где V - количество вершин, D - матрица смежности
{
	int k;//множество других вершин
	for (i=0; i<V; i++) 
		D[i][i] = -1000; //каждому элементы матрицы присвоили вес, равный -1000

	for (k=0; k<V; k++)
		for (i=0; i<V; i++)
			for (j=0; j<V; j++)
				if (D[i][k] && D[k][j] && i!=j)
				if (D[i][k]+D[k][j]<D[i][j] || D[i][j]==0)
					D[i][j]=D[i][k]+D[k][j];

			for (i=0; i<V; i++)
			{
				for (j=0; j<V; j++) 
					cout << D[i][j] << "\t";
					cout<<endl;
			}
}

int main()
{
	setlocale(LC_ALL, "Rus");
	cout<<"Количество вершин в графе > "; 
	cin>>n;

	cout<<"Введите матрицу весов ребер:\n";
	for (i=0; i<n; i++)
		for (j=0; j<n; j++)
		{	
			cout << "GR[" << i+1 << "][" << j+1 << "] > ";
			cin>>GR[i][j];
		}

	cout<<"Матрица кратчайших путей:"<<endl;
	FU(GR, n);

	return 0;
}